# PART 1: 기초
## CHAPTER 1 - 자바 8을 눈여겨봐야하는 이유
- 언어 생태계의 모든 언어는 변화해서 살아남거나 그대로 머물면서 사라지게 되는 상황에 놓인다.  
지금은 자바의 위치가 견고하지만 코볼과 같은 언어의 선례를 떠올리면 자바가 영원히 지배적인 위치를 유지할 수 있는 것은 아닐 수 있다
- 자바 8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능을 제공한다
- 기존의 자바 프로그래밍 기법으로는 멀티코어 프로세서를 온전히 활용하기 어렵다
- 함수는 일급값이다. 메서드를 어떻게 함수형값으로 넘겨주는지, 익명 함수(람다)를 어떻게 구현하는지 기억하자
- 자바 8의 스트림 개념중 일부는 컬렉션에서 가져온 것 이다.  
스트림과 컬렉션을 적절하게 활용하면스틈의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수 있다
- 인터페이스에서 디폴트 메서드를 이용하면 메서드 바디를 제공할 수 있으므로 인터페이스를 구현하는 다른 클래스에서 해당 메서드를 구현하지 않아도 된다
- 함수형 프로그래밍에서 null 처리 방법과 패턴 매칭 활용등 흥미로운 기법을 발견할 수 있었다

## CHAPTER 2 - 동작 파라미터화 코드 전달하기
- 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다
- 동작파라미터화를 이용하면 변화하는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며 나중에 엔지니어링 비용을 줄일 수 있다
- 코드 전달 기법을 이용하면 동작을 메서드의 인수로 전달할 수 있다.  
하지만 자바 8 이전에는 코드를 지저분하게 구현해야 했다.  
익명클래스로도 어느 정도 코드를 깔끔하게 만들 수 있지만  
자바 8에서는 인터페이스를 상속받아 여러 클래스를 구현해야 하는 수고를 없앨 수 있는 방법을 제공한다
- 자바 API의 많은 메서드는 정렬, 스레드, GUI 처리 등을 포함한 다양한 동작으로 파라미터화 할 수 있다

## CHAPTER 3 - 람다 표현식

### 함수형 인터페이스 사용
#### Predicate
test라는 추상메서드를 정의하며 test는 제네릭 형식 T의 객체를 인수로 받아 불린을 반환한다  
T형식의 객체를 사용하는 불린 표현식이 필요한 상황에서 Predicate 인터페이스를 사용할 수 있다

#### Consumer
제네릭 형식 T 객체를 받아서 void를 반환하는 accept라는 추상 메서드를 정의한다  
T 형식의 객체를 인수로 받아서 어떤 동작을 수행하고 싶을 때 Consumer 인터페이스를 사용할 수 있다  
예를 들어 Integer 리스트를 인수로 받아서 각 항목에 어떤 동작을 수행하는 forEach 메서드를 정의할 때 Consumer를 활용할 수 있다

#### Function
제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 apply라는 추상 메서드를 정의한다  
입력을 출력으로 매핑하는 람다를 정의할 때 Function 인터페이스를 활용할 수 있다  
예를 들면 사과의 무게 정보를 추출하거나 문자열을 길이와 매핑

#### 기본형 특화
- **박싱(boxing)**: 기본형을 참조형으로 변환할 수 있는 기능  
- **언박싱(unboxing)**: 참조형을 기본형으로 변환하는 반대 동작
- **오토박싱(autoboxing)**: 프로그래머가 편리하게 코드를 구현할 수 있도록 박싱과 언박싱이 자동으로 이루어지는 것

### 메서드 레퍼런스를 만드는 방법
1. 정적 메서드 레퍼런스
    - 예를 들어 `Integer`의 `parseInt` 메서드는 **Integer::parseInt**로 표현할 수 있다
2. 다양한 형식의 인스턴스 메서드 레퍼런스
    - 예를 들어 `String`의 `length` 메서드는 **String::length**로 표현할 수 있다
3. 기존 객체의 인스턴스 메서드 레퍼런스
    - 예를 들어 `Transaction` 객체를 할당 받은 `expensiveTransaction` 지역 변수가 있고  
    `Transaction` 객체에는 `getValue` 메서드가 있다면, 이를 **expensiveTransaction::getValue**라고 표현할 수 있다

### 생성자 레퍼런스
**ClassName::new**처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 레퍼런스를 만들 수 있다

### 요약
- **람다 표현식**은 익명 함수의 일종이다. 이름은 없지만, 파라미터 리스트, 바디, 반환형식을 가지며 예외를 던질 수 있다
- 람다 표현식으로 간결한 코드를 구현할 수 있다
- 함수형 인터페이스는 하나의 추상 메서드만을 정의하는 인터페이스다
- 함수형 인터페이스를 기대하는 곳에서만 람다 표현식을 사용할 수 있다
- 람다 표현식을 이용해서 함수형 인터페이스의 추상 메서드를 즉석으로 제공할 수 있으며  
**람다 표현식 전체가 함수형 인터페이스의 인스턴스로 취급된다**
- `java.util.function` 패키지는 `Predicate<T>`, `Function<T, R>`, `Supplier<T>`, `Consumer<T>`, `BinaryOperator<T>` 등을  
포함해서 자주 사용하는 다양한 함수형 인터페이스를 제공한다
- 자바 8은 `Predicate<T>`와 `Function<T, R>` 같은 제네릭 함수형 인터페이스와 관련한 박싱 동작을 피할 수 있도록  
`IntPredicate`, `IntToLongFunction` 등과 같은 기본형 트고하 인터페이스도 제공한다
- 실행 어라운드 패턴(예를 들자면 자원 할당, 자원 정리 등 코드 중간에 실행해야 하는 메서드에 꼭 필요한 코드)  
을 람다와 활용하면 유연성과 재사용성을 추가로 얻을 수 있다
- 람다 표현식의 기대 형식을 **대상** 형식이라고 한다
- 메서드 레퍼런스를 이용하면 기존의 메서드 구현을 재사용하고 직접 전달할 수 있다
- `Comparator`,`Predicate`,`Function` 같은 함수형 인터페이스는 람다 표현식을 조합할 수 있는 다양한 디폴트 메서드를 제공한다